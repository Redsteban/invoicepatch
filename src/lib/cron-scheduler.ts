// Cron Job Scheduler for Automated Invoice Generation
// Handles Saturday morning auto-generation and notification scheduling

import { 
  stackPayrollCalendar, 
  PayrollPeriod,
  AutoInvoiceConfig,
  WorkPeriodData,
  formatDate 
} from './payroll-calendar';
import { 
  autoInvoiceGenerator, 
  AutoGeneratedInvoice,
  scheduleInvoiceGeneration 
} from './auto-invoice-generator';

export interface CronJob {
  id: string;
  name: string;
  schedule: string; // Cron expression
  type: 'invoice_generation' | 'notification_reminder' | 'deadline_check' | 'calendar_sync';
  enabled: boolean;
  lastRun?: Date;
  nextRun: Date;
  runCount: number;
  errorCount: number;
  description: string;
}

export interface CronJobResult {
  jobId: string;
  success: boolean;
  executionTime: number;
  message: string;
  data?: any;
  error?: string;
}

export interface SchedulerConfig {
  timezone: string;
  enabledJobs: string[];
  notifications: {
    onSuccess: boolean;
    onFailure: boolean;
    emailRecipients: string[];
  };
}

export class CronScheduler {
  private jobs: Map<string, CronJob> = new Map();
  private intervals: Map<string, NodeJS.Timeout> = new Map();
  private config: SchedulerConfig;

  constructor(config: SchedulerConfig) {
    this.config = config;
    this.initializeDefaultJobs();
  }

  // Initialize default cron jobs for Stack payroll automation
  private initializeDefaultJobs() {
    const defaultJobs: CronJob[] = [
      {
        id: 'saturday-invoice-generation',
        name: 'Saturday Invoice Auto-Generation',
        schedule: '0 8 * * 6', // Every Saturday at 8 AM
        type: 'invoice_generation',
        enabled: true,
        nextRun: this.getNextRunTime('0 8 * * 6'),
        runCount: 0,
        errorCount: 0,
        description: 'Automatically generate invoices every Saturday morning for Stack payroll periods'
      },
      {
        id: 'tuesday-reminder',
        name: 'Tuesday Invoice Reminders',
        schedule: '0 9 * * 2', // Every Tuesday at 9 AM
        type: 'notification_reminder',
        enabled: true,
        nextRun: this.getNextRunTime('0 9 * * 2'),
        runCount: 0,
        errorCount: 0,
        description: 'Send reminder notifications to contractors about pending invoices'
      },
      {
        id: 'thursday-urgent',
        name: 'Thursday Urgent Reminders',
        schedule: '0 10 * * 4', // Every Thursday at 10 AM
        type: 'notification_reminder',
        enabled: true,
        nextRun: this.getNextRunTime('0 10 * * 4'),
        runCount: 0,
        errorCount: 0,
        description: 'Send urgent reminders for invoices due tomorrow'
      },
      {
        id: 'friday-final-notice',
        name: 'Friday Final Notice',
        schedule: '0 8 * * 5', // Every Friday at 8 AM
        type: 'notification_reminder',
        enabled: true,
        nextRun: this.getNextRunTime('0 8 * * 5'),
        runCount: 0,
        errorCount: 0,
        description: 'Send final notice for invoices due today'
      },
      {
        id: 'daily-deadline-check',
        name: 'Daily Deadline Monitoring',
        schedule: '0 7 * * *', // Every day at 7 AM
        type: 'deadline_check',
        enabled: true,
        nextRun: this.getNextRunTime('0 7 * * *'),
        runCount: 0,
        errorCount: 0,
        description: 'Check for upcoming deadlines and overdue invoices'
      },
      {
        id: 'calendar-sync',
        name: 'Weekly Calendar Sync',
        schedule: '0 6 * * 1', // Every Monday at 6 AM
        type: 'calendar_sync',
        enabled: true,
        nextRun: this.getNextRunTime('0 6 * * 1'),
        runCount: 0,
        errorCount: 0,
        description: 'Sync with Stack payroll calendar and update schedules'
      }
    ];

    defaultJobs.forEach(job => {
      this.jobs.set(job.id, job);
    });
  }

  // Start the scheduler
  start(): void {
    console.log('Starting Cron Scheduler for Stack Invoice Automation');
    
    this.jobs.forEach((job, jobId) => {
      if (job.enabled && this.config.enabledJobs.includes(jobId)) {
        this.scheduleJob(job);
      }
    });
  }

  // Stop the scheduler
  stop(): void {
    console.log('Stopping Cron Scheduler');
    
    this.intervals.forEach((interval) => {
      clearInterval(interval);
    });
    this.intervals.clear();
  }

  // Schedule a specific job
  private scheduleJob(job: CronJob): void {
    const interval = setInterval(async () => {
      if (this.shouldRunJob(job)) {
        await this.executeJob(job);
      }
    }, 60000); // Check every minute

    this.intervals.set(job.id, interval);
    console.log(`Scheduled job: ${job.name} (${job.schedule})`);
  }

  // Check if job should run based on cron schedule
  private shouldRunJob(job: CronJob): boolean {
    const now = new Date();
    const lastRun = job.lastRun;
    
    // Simple check - in production would use proper cron parsing
    if (!lastRun || now >= job.nextRun) {
      return true;
    }
    
    return false;
  }

  // Execute a cron job
  private async executeJob(job: CronJob): Promise<CronJobResult> {
    const startTime = Date.now();
    console.log(`Executing job: ${job.name}`);

    try {
      let result: any;

      switch (job.type) {
        case 'invoice_generation':
          result = await this.executeInvoiceGeneration();
          break;
        case 'notification_reminder':
          result = await this.executeNotificationReminder(job.id);
          break;
        case 'deadline_check':
          result = await this.executeDeadlineCheck();
          break;
        case 'calendar_sync':
          result = await this.executeCalendarSync();
          break;
        default:
          throw new Error(`Unknown job type: ${job.type}`);
      }

      const executionTime = Date.now() - startTime;
      job.lastRun = new Date();
      job.nextRun = this.getNextRunTime(job.schedule);
      job.runCount++;

      const jobResult: CronJobResult = {
        jobId: job.id,
        success: true,
        executionTime,
        message: `Job executed successfully`,
        data: result
      };

      await this.notifyJobCompletion(job, jobResult);
      return jobResult;

    } catch (error) {
      const executionTime = Date.now() - startTime;
      job.errorCount++;

      const jobResult: CronJobResult = {
        jobId: job.id,
        success: false,
        executionTime,
        message: `Job failed`,
        error: error instanceof Error ? error.message : 'Unknown error'
      };

      await this.notifyJobCompletion(job, jobResult);
      return jobResult;
    }
  }

  // Execute invoice generation for current date
  private async executeInvoiceGeneration(): Promise<any> {
    const today = new Date();
    
    // Check if today is an invoice generation day
    const periodsToGenerate = stackPayrollCalendar.getPeriodsForInvoiceGeneration(today);
    
    if (periodsToGenerate.length === 0) {
      return {
        message: 'No invoices to generate today',
        periodsChecked: 0,
        invoicesGenerated: 0
      };
    }

    // Generate invoices for all relevant periods
    const generatedInvoices = await scheduleInvoiceGeneration(today);

    return {
      message: `Generated ${generatedInvoices.length} invoices for ${periodsToGenerate.length} periods`,
      periodsChecked: periodsToGenerate.length,
      invoicesGenerated: generatedInvoices.length,
      invoices: generatedInvoices.map(inv => ({
        id: inv.id,
        invoiceNumber: inv.invoiceNumber,
        contractor: inv.contractorId,
        period: inv.workPeriod,
        amount: inv.total
      }))
    };
  }

  // Execute notification reminders
  private async executeNotificationReminder(jobId: string): Promise<any> {
    const today = new Date();
    const notifications = autoInvoiceGenerator.getPendingNotifications(today);
    
    let notificationsSent = 0;
    const results: any[] = [];

    for (const notification of notifications) {
      try {
        // In a real implementation, this would send actual emails/SMS
        const content = autoInvoiceGenerator.generateNotificationContent(notification, null as any);
        
        if (content) {
          // Simulate sending notification
          console.log(`Sending ${notification.type} notification to contractor ${notification.contractorId}`);
          
          // Mark as sent
          autoInvoiceGenerator.markNotificationSent(
            `${notification.type}-${notification.invoiceId}-${notification.contractorId}`
          );
          
          notificationsSent++;
          results.push({
            contractorId: notification.contractorId,
            type: notification.type,
            subject: content.subject,
            sent: true
          });
        }
      } catch (error) {
        results.push({
          contractorId: notification.contractorId,
          type: notification.type,
          sent: false,
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    }

    return {
      message: `Sent ${notificationsSent} notifications`,
      notificationsChecked: notifications.length,
      notificationsSent,
      details: results
    };
  }

  // Execute deadline checking
  private async executeDeadlineCheck(): Promise<any> {
    const upcomingDeadlines = stackPayrollCalendar.getUpcomingDeadlines();
    const today = new Date();
    
    const results = {
      upcomingDeadlines: upcomingDeadlines.length,
      criticalDeadlines: 0,
      overdueItems: 0,
      warningsIssued: 0
    };

    // Check for critical deadlines (next 24 hours)
    const tomorrow = new Date(today.getTime() + 24 * 60 * 60 * 1000);
    const criticalDeadlines = upcomingDeadlines.filter(period => 
      period.cutOffDate <= tomorrow
    );
    
    results.criticalDeadlines = criticalDeadlines.length;

    // In a real implementation, would check database for overdue invoices
    // For now, just return the structure

    return results;
  }

  // Execute calendar synchronization
  private async executeCalendarSync(): Promise<any> {
    // In a real implementation, this would:
    // 1. Fetch latest Stack payroll calendar
    // 2. Update internal calendar if changes detected
    // 3. Reschedule any affected jobs
    // 4. Notify contractors of calendar changes

    const currentPeriods = stackPayrollCalendar.getYearSummary(2025);
    
    return {
      message: 'Calendar sync completed',
      periodsFound: currentPeriods.totalPeriods,
      workDaysTotal: currentPeriods.totalWorkDays,
      lastUpdated: new Date().toISOString()
    };
  }

  // Calculate next run time based on cron schedule
  private getNextRunTime(cronSchedule: string): Date {
    // Simplified cron parsing - in production would use a proper cron library
    const now = new Date();
    const [minute, hour, dayMonth, month, dayWeek] = cronSchedule.split(' ');
    
    // For simplicity, just add 24 hours for daily jobs, 7 days for weekly
    if (dayWeek !== '*') {
      // Weekly job
      const nextWeek = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);
      nextWeek.setHours(parseInt(hour), parseInt(minute), 0, 0);
      return nextWeek;
    } else {
      // Daily job
      const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1000);
      tomorrow.setHours(parseInt(hour), parseInt(minute), 0, 0);
      return tomorrow;
    }
  }

  // Notify about job completion
  private async notifyJobCompletion(job: CronJob, result: CronJobResult): Promise<void> {
    if (this.config.notifications.onSuccess && result.success) {
      console.log(`✅ Job ${job.name} completed successfully in ${result.executionTime}ms`);
    }
    
    if (this.config.notifications.onFailure && !result.success) {
      console.error(`❌ Job ${job.name} failed: ${result.error}`);
      
      // In production, would send email alerts to administrators
      if (this.config.notifications.emailRecipients.length > 0) {
        // Send email notification
      }
    }
  }

  // Get job status
  getJobStatus(jobId: string): CronJob | null {
    return this.jobs.get(jobId) || null;
  }

  // Get all jobs
  getAllJobs(): CronJob[] {
    return Array.from(this.jobs.values());
  }

  // Enable/disable a job
  toggleJob(jobId: string, enabled: boolean): boolean {
    const job = this.jobs.get(jobId);
    if (!job) return false;

    job.enabled = enabled;
    
    if (enabled && this.config.enabledJobs.includes(jobId)) {
      this.scheduleJob(job);
    } else {
      const interval = this.intervals.get(jobId);
      if (interval) {
        clearInterval(interval);
        this.intervals.delete(jobId);
      }
    }

    return true;
  }

  // Manually trigger a job
  async triggerJob(jobId: string): Promise<CronJobResult> {
    const job = this.jobs.get(jobId);
    if (!job) {
      throw new Error(`Job not found: ${jobId}`);
    }

    return await this.executeJob(job);
  }

  // Get scheduler statistics
  getStats() {
    const jobs = Array.from(this.jobs.values());
    
    return {
      totalJobs: jobs.length,
      enabledJobs: jobs.filter(job => job.enabled).length,
      totalRuns: jobs.reduce((sum, job) => sum + job.runCount, 0),
      totalErrors: jobs.reduce((sum, job) => sum + job.errorCount, 0),
      successRate: this.calculateSuccessRate(jobs),
      nextRuns: jobs
        .filter(job => job.enabled)
        .map(job => ({
          jobId: job.id,
          name: job.name,
          nextRun: job.nextRun
        }))
        .sort((a, b) => a.nextRun.getTime() - b.nextRun.getTime())
    };
  }

  private calculateSuccessRate(jobs: CronJob[]): number {
    const totalRuns = jobs.reduce((sum, job) => sum + job.runCount, 0);
    const totalErrors = jobs.reduce((sum, job) => sum + job.errorCount, 0);
    
    if (totalRuns === 0) return 100;
    return Math.round(((totalRuns - totalErrors) / totalRuns) * 100);
  }
}

// Default scheduler configuration
export const defaultSchedulerConfig: SchedulerConfig = {
  timezone: 'America/Edmonton', // Alberta, Canada timezone
  enabledJobs: [
    'saturday-invoice-generation',
    'tuesday-reminder',
    'thursday-urgent',
    'friday-final-notice',
    'daily-deadline-check',
    'calendar-sync'
  ],
  notifications: {
    onSuccess: false, // Only log successes
    onFailure: true,  // Alert on failures
    emailRecipients: []
  }
};

// Global scheduler instance
export const stackCronScheduler = new CronScheduler(defaultSchedulerConfig);

// Utility functions
export const startStackAutomation = (): void => {
  stackCronScheduler.start();
  console.log('🚀 Stack Production Testing automation started');
};

export const stopStackAutomation = (): void => {
  stackCronScheduler.stop();
  console.log('⏹️ Stack Production Testing automation stopped');
};

export const getAutomationStatus = () => {
  return stackCronScheduler.getStats();
}; 