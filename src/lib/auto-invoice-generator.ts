// Automated Invoice Generation System for Stack Production Testing
// Handles automatic invoice creation based on payroll calendar

import { 
  PayrollPeriod, 
  AutoInvoiceConfig, 
  WorkPeriodData, 
  NotificationSchedule,
  stackPayrollCalendar,
  formatCurrency,
  formatDate 
} from './payroll-calendar';

export interface AutoGeneratedInvoice {
  id: string;
  invoiceNumber: string;
  contractorId: string;
  periodId: string;
  client: string;
  project: string;
  afeCode: string;
  workPeriod: string;
  workPeriodStart: Date;
  workPeriodEnd: Date;
  status: 'auto_generated' | 'in_progress' | 'submitted' | 'approved' | 'paid';
  
  // Financial details
  dayRate: number;
  daysWorked: number;
  regularHours: number;
  overtimeHours: number;
  overtimeRate: number;
  
  // Equipment and travel
  truckRate?: number;
  truckDays?: number;
  mileage: number;
  mileageRate: number;
  
  // Expenses
  expenses: Array<{
    category: string;
    amount: number;
    description: string;
    receiptRequired: boolean;
    receiptUploaded: boolean;
  }>;
  
  // Calculated totals
  laborSubtotal: number;
  truckSubtotal: number;
  mileageSubtotal: number;
  expenseSubtotal: number;
  subtotal: number;
  gst: number;
  total: number;
  
  // Dates and deadlines
  createdDate: Date;
  dueDate: Date;
  submissionDeadline: Date;
  
  // Completion tracking
  completionPercentage: number;
  missingItems: string[];
  readyToSubmit: boolean;
  
  // Metadata
  autoGenerated: boolean;
  generationSource: 'payroll_calendar' | 'manual' | 'duplicate';
  notes?: string;
}

export interface InvoiceTemplate {
  contractorId: string;
  clientName: string;
  projectName: string;
  defaultAFECode: string;
  standardRates: {
    dayRate: number;
    overtimeMultiplier: number;
    truckRate?: number;
    mileageRate: number;
  };
  commonExpenseCategories: string[];
  paymentTerms: string;
  taxSettings: {
    gstRate: number;
    gstNumber?: string;
  };
}

export class AutoInvoiceGenerator {
  private templates: Map<string, InvoiceTemplate> = new Map();
  private notifications: NotificationSchedule[] = [];

  constructor() {
    this.initializeDefaultTemplates();
  }

  // Initialize default templates for Stack Production Testing contractors
  private initializeDefaultTemplates() {
    const stackTemplate: InvoiceTemplate = {
      contractorId: 'default',
      clientName: 'Stack Production Testing Inc.',
      projectName: 'Production Testing Services',
      defaultAFECode: 'STACK-2025-',
      standardRates: {
        dayRate: 800,
        overtimeMultiplier: 1.5,
        truckRate: 150,
        mileageRate: 0.68
      },
      commonExpenseCategories: [
        'Accommodation',
        'Meals',
        'Fuel',
        'Equipment Rental',
        'Safety Equipment',
        'Communication',
        'Other'
      ],
      paymentTerms: 'Net 14 Days',
      taxSettings: {
        gstRate: 0.05
      }
    };
    
    this.templates.set('stack-default', stackTemplate);
  }

  // Generate invoice automatically for a payroll period
  async generateInvoiceForPeriod(
    period: PayrollPeriod, 
    config: AutoInvoiceConfig
  ): Promise<AutoGeneratedInvoice> {
    const template = this.getTemplate(config.contractorId);
    const invoiceNumber = this.generateInvoiceNumber(period, config);
    
    // Calculate work period details
    const workDays = stackPayrollCalendar.calculateWorkDays(period);
    const standardHours = workDays * 8; // Assuming 8-hour days
    
    // Create base invoice with standard values
    const invoice: AutoGeneratedInvoice = {
      id: `auto-${Date.now()}-${config.contractorId}`,
      invoiceNumber,
      contractorId: config.contractorId,
      periodId: period.id,
      client: template.clientName,
      project: template.projectName,
      afeCode: `${template.defaultAFECode}${period.month.toString().padStart(2, '0')}${period.year}`,
      workPeriod: stackPayrollCalendar.formatPeriod(period),
      workPeriodStart: period.workPeriodStart,
      workPeriodEnd: period.workPeriodEnd,
      status: 'auto_generated',
      
      // Pre-populate with standard rates
      dayRate: config.standardDayRate || template.standardRates.dayRate,
      daysWorked: 0, // To be filled by contractor
      regularHours: 0, // To be filled by contractor
      overtimeHours: 0, // To be filled by contractor
      overtimeRate: (config.standardDayRate || template.standardRates.dayRate) / 8 * template.standardRates.overtimeMultiplier,
      
      // Equipment defaults
      truckRate: config.standardTruckRate || template.standardRates.truckRate,
      truckDays: 0, // To be filled if applicable
      mileage: 0, // To be filled by contractor
      mileageRate: config.standardMileageRate || template.standardRates.mileageRate,
      
      // Empty expenses array with common categories as placeholders
      expenses: template.commonExpenseCategories.map(category => ({
        category,
        amount: 0,
        description: '',
        receiptRequired: true,
        receiptUploaded: false
      })),
      
      // Initialize calculated totals (will be recalculated)
      laborSubtotal: 0,
      truckSubtotal: 0,
      mileageSubtotal: 0,
      expenseSubtotal: 0,
      subtotal: 0,
      gst: 0,
      total: 0,
      
      // Dates
      createdDate: new Date(),
      dueDate: period.payDate,
      submissionDeadline: period.cutOffDate,
      
      // Completion tracking
      completionPercentage: 15, // Basic structure created
      missingItems: [
        'Time entries required',
        'Days worked not specified',
        'Mileage needs to be entered',
        'Expense receipts pending'
      ],
      readyToSubmit: false,
      
      // Metadata
      autoGenerated: true,
      generationSource: 'payroll_calendar',
      notes: `Auto-generated for Stack payroll period ${stackPayrollCalendar.formatPeriod(period)}. Please review and complete all required fields.`
    };

    // Calculate initial totals
    this.calculateTotals(invoice);
    
    // Schedule notifications
    await this.scheduleNotifications(invoice, period);
    
    return invoice;
  }

  // Generate invoice number based on period and contractor
  private generateInvoiceNumber(period: PayrollPeriod, config: AutoInvoiceConfig): string {
    const year = period.year.toString().slice(-2);
    const month = period.month.toString().padStart(2, '0');
    const periodNum = period.id.split('-').pop() || '01';
    const contractorInitials = config.companyName
      .split(' ')
      .map(word => word.charAt(0))
      .join('')
      .slice(0, 3)
      .toUpperCase();
    
    return `INV-${year}${month}${periodNum}-${contractorInitials}`;
  }

  // Calculate invoice totals
  private calculateTotals(invoice: AutoGeneratedInvoice): void {
    // Labor calculation
    const regularPay = (invoice.daysWorked * invoice.dayRate);
    const overtimePay = invoice.overtimeHours * invoice.overtimeRate;
    invoice.laborSubtotal = regularPay + overtimePay;
    
    // Truck calculation
    invoice.truckSubtotal = (invoice.truckDays || 0) * (invoice.truckRate || 0);
    
    // Mileage calculation
    invoice.mileageSubtotal = invoice.mileage * invoice.mileageRate;
    
    // Expense calculation
    invoice.expenseSubtotal = invoice.expenses.reduce((sum, exp) => sum + exp.amount, 0);
    
    // Subtotal
    invoice.subtotal = invoice.laborSubtotal + invoice.truckSubtotal + invoice.mileageSubtotal + invoice.expenseSubtotal;
    
    // GST (5% in Canada)
    invoice.gst = invoice.subtotal * 0.05;
    
    // Total
    invoice.total = invoice.subtotal + invoice.gst;
    
    // Update completion percentage
    this.updateCompletionStatus(invoice);
  }

  // Update completion status and missing items
  private updateCompletionStatus(invoice: AutoGeneratedInvoice): void {
    const missingItems: string[] = [];
    let completedItems = 0;
    const totalItems = 8; // Total items to check
    
    // Check days worked
    if (invoice.daysWorked > 0) {
      completedItems++;
    } else {
      missingItems.push('Days worked not specified');
    }
    
    // Check regular hours
    if (invoice.regularHours > 0) {
      completedItems++;
    } else {
      missingItems.push('Regular hours not entered');
    }
    
    // Check if time entries exist (this would need to be checked against actual time tracking data)
    // For now, assume time entries are missing if days worked is 0
    if (invoice.daysWorked > 0) {
      completedItems++;
    } else {
      missingItems.push('Time entries required');
    }
    
    // Check mileage (optional, so only flag if partially entered)
    if (invoice.mileage >= 0) {
      completedItems++;
    }
    
    // Check expenses - flag if any have amounts but no receipts
    const expensesWithAmounts = invoice.expenses.filter(exp => exp.amount > 0);
    const expensesWithReceipts = expensesWithAmounts.filter(exp => exp.receiptUploaded);
    
    if (expensesWithAmounts.length === 0 || expensesWithAmounts.length === expensesWithReceipts.length) {
      completedItems++;
    } else {
      missingItems.push(`${expensesWithAmounts.length - expensesWithReceipts.length} expense receipts pending`);
    }
    
    // Check if AFE code is complete
    if (invoice.afeCode && invoice.afeCode.length > 10) {
      completedItems++;
    } else {
      missingItems.push('AFE code needs completion');
    }
    
    // Check if project details are complete
    if (invoice.project && invoice.project !== 'Production Testing Services') {
      completedItems++;
    } else {
      missingItems.push('Specific project details needed');
    }
    
    // Basic invoice structure (always complete for auto-generated)
    completedItems++;
    
    // Calculate completion percentage
    invoice.completionPercentage = Math.round((completedItems / totalItems) * 100);
    invoice.missingItems = missingItems;
    invoice.readyToSubmit = missingItems.length === 0 && invoice.total > 0;
  }

  // Schedule notifications for the invoice
  private async scheduleNotifications(invoice: AutoGeneratedInvoice, period: PayrollPeriod): Promise<void> {
    const notificationSchedule = stackPayrollCalendar.getNotificationSchedule(period);
    
    for (const notification of notificationSchedule) {
      notification.invoiceId = invoice.id;
      notification.contractorId = invoice.contractorId;
      this.notifications.push(notification);
    }
  }

  // Get template for contractor
  private getTemplate(contractorId: string): InvoiceTemplate {
    return this.templates.get(contractorId) || this.templates.get('stack-default')!;
  }

  // Set custom template for contractor
  setContractorTemplate(contractorId: string, template: InvoiceTemplate): void {
    this.templates.set(contractorId, template);
  }

  // Generate invoices for all contractors for a specific date
  async generateInvoicesForDate(date: Date): Promise<AutoGeneratedInvoice[]> {
    const periods = stackPayrollCalendar.getPeriodsForInvoiceGeneration(date);
    const invoices: AutoGeneratedInvoice[] = [];
    
    // This would typically fetch contractor configs from database
    // For demo purposes, using sample configs
    const sampleConfigs: AutoInvoiceConfig[] = [
      {
        contractorId: 'contractor-001',
        companyName: 'Mike Thompson Services',
        standardDayRate: 850,
        standardTruckRate: 150,
        standardMileageRate: 0.68,
        defaultProjectCode: 'MONTNEY-DRILL',
        defaultAFECode: 'AFE-2025-001',
        autoSubmit: false,
        notificationSettings: {
          email: true,
          sms: true,
          inApp: true
        }
      },
      {
        contractorId: 'contractor-002',
        companyName: 'Sarah Chen Consulting',
        standardDayRate: 800,
        standardMileageRate: 0.68,
        defaultProjectCode: 'PIPELINE-INTEGRITY',
        defaultAFECode: 'AFE-2025-002',
        autoSubmit: false,
        notificationSettings: {
          email: true,
          sms: false,
          inApp: true
        }
      }
    ];
    
    for (const period of periods) {
      for (const config of sampleConfigs) {
        const invoice = await this.generateInvoiceForPeriod(period, config);
        invoices.push(invoice);
      }
    }
    
    return invoices;
  }

  // Update invoice with actual work data
  updateInvoiceWithWorkData(invoice: AutoGeneratedInvoice, workData: WorkPeriodData): AutoGeneratedInvoice {
    // Update work details
    invoice.daysWorked = workData.daysWorked;
    invoice.regularHours = workData.hoursWorked;
    invoice.overtimeHours = workData.overtimeHours;
    invoice.truckDays = workData.truckDays || 0;
    invoice.mileage = workData.mileage;
    
    // Update expenses
    for (const expense of workData.expenses) {
      const existingExpense = invoice.expenses.find(exp => exp.category === expense.category);
      if (existingExpense) {
        existingExpense.amount = expense.amount;
        existingExpense.description = expense.description;
        existingExpense.receiptUploaded = !!expense.receiptUrl;
      } else {
        invoice.expenses.push({
          category: expense.category,
          amount: expense.amount,
          description: expense.description,
          receiptRequired: true,
          receiptUploaded: !!expense.receiptUrl
        });
      }
    }
    
    // Recalculate totals
    this.calculateTotals(invoice);
    
    // Update status if ready
    if (invoice.readyToSubmit) {
      invoice.status = 'in_progress';
    }
    
    return invoice;
  }

  // Get pending notifications for a date
  getPendingNotifications(date: Date): NotificationSchedule[] {
    const dateStr = date.toDateString();
    return this.notifications.filter(notification => 
      !notification.sent && 
      notification.scheduledDate.toDateString() === dateStr
    );
  }

  // Mark notification as sent
  markNotificationSent(notificationId: string): void {
    const notification = this.notifications.find(n => 
      `${n.type}-${n.invoiceId}-${n.contractorId}` === notificationId
    );
    if (notification) {
      notification.sent = true;
    }
  }

  // Get invoice completion summary
  getInvoiceCompletionSummary(invoices: AutoGeneratedInvoice[]) {
    const total = invoices.length;
    const readyToSubmit = invoices.filter(inv => inv.readyToSubmit).length;
    const inProgress = invoices.filter(inv => inv.completionPercentage > 15 && !inv.readyToSubmit).length;
    const notStarted = total - readyToSubmit - inProgress;
    
    const totalValue = invoices.reduce((sum, inv) => sum + inv.total, 0);
    const completedValue = invoices.filter(inv => inv.readyToSubmit).reduce((sum, inv) => sum + inv.total, 0);
    
    return {
      total,
      readyToSubmit,
      inProgress,
      notStarted,
      totalValue,
      completedValue,
      averageCompletion: total > 0 ? Math.round(invoices.reduce((sum, inv) => sum + inv.completionPercentage, 0) / total) : 0
    };
  }

  // Generate notification content
  generateNotificationContent(notification: NotificationSchedule, invoice: AutoGeneratedInvoice) {
    const period = stackPayrollCalendar.getPeriodById(invoice.periodId);
    if (!period) return null;
    
    const daysUntilDeadline = Math.ceil((period.cutOffDate.getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24));
    
    switch (notification.type) {
      case 'invoice_created':
        return {
          subject: `Invoice Ready for Review - ${invoice.workPeriod}`,
          message: `Your invoice for ${invoice.workPeriod} has been auto-generated and is ready for review. Please complete your time entries and expenses by ${formatDate(period.cutOffDate)}.`,
          action: 'Review Invoice',
          urgency: 'info'
        };
      
      case 'reminder_tuesday':
        return {
          subject: `Invoice Reminder - ${invoice.workPeriod}`,
          message: `Reminder: Your invoice for ${invoice.workPeriod} is ${invoice.completionPercentage}% complete. Deadline: ${formatDate(period.cutOffDate)} (${daysUntilDeadline} days remaining).`,
          action: 'Complete Invoice',
          urgency: 'low'
        };
      
      case 'urgent_thursday':
        return {
          subject: `URGENT: Invoice Due Soon - ${invoice.workPeriod}`,
          message: `URGENT: Your invoice for ${invoice.workPeriod} is due tomorrow (${formatDate(period.cutOffDate)}). Current completion: ${invoice.completionPercentage}%. Missing: ${invoice.missingItems.join(', ')}.`,
          action: 'Complete Now',
          urgency: 'high'
        };
      
      case 'final_friday':
        return {
          subject: `FINAL NOTICE: Invoice Due Today - ${invoice.workPeriod}`,
          message: `FINAL NOTICE: Your invoice for ${invoice.workPeriod} is due TODAY (${formatDate(period.cutOffDate)}). Submit now to ensure timely payment on ${formatDate(period.payDate)}.`,
          action: 'Submit Invoice',
          urgency: 'critical'
        };
      
      default:
        return null;
    }
  }
}

// Default instance
export const autoInvoiceGenerator = new AutoInvoiceGenerator();

// Utility functions for invoice automation
export const scheduleInvoiceGeneration = (date: Date): Promise<AutoGeneratedInvoice[]> => {
  return autoInvoiceGenerator.generateInvoicesForDate(date);
};

export const checkForInvoiceGenerationToday = (): boolean => {
  return stackPayrollCalendar.isInvoiceGenerationDay();
};

export const getUpcomingInvoiceDeadlines = (): PayrollPeriod[] => {
  return stackPayrollCalendar.getUpcomingDeadlines();
}; 